{
    // The workbench consists of UI connected to a number of external plugins,
    // which are organized into 'parsers', 'file_detail_views', and
    // 'decision_views'.  These are  supported through the defining of the
    // "build" environment.
    //
    // The reason this is a custom format instead of a standard Dockerfile is
    // so that the entire deployment might be specified in a single location.
    // Dockerfile is necessary because many external plugins have their own
    // requirements, etc.
    //
    // Everything in this file except 'build' is live-reloaded when used with
    // the --development flag. This applies mostly to plugins, but can also
    // apply to 'parsers' when the DB is reset through the UI (use on small
    // collections of files only).


    // The name of the docker image to be produced.
    name: 'galois-workbench-icc',

    parsers: {
        argyllCms: {
          exec: ['iccdump', '-v', '3', '<inputFile>'],
          version: 'test',
          parse: {
            type: 'regex-counter',
            stdstar: {
              '.*': {
                nameReplace: {'[0-9]': ''},
              },
            },
          },
        },
        littleCms: {
          exec: ['psicc', '-c', '2', '-b', '-i', '<inputFile>'],
          version: 'test',
          parse: {
            type: 'regex-counter',
            stdstar: {
              '.*': {
                nameReplace: {'[0-9]': ''},
              },
            },
          },
        },
        refIccMax: {
          exec: ['/opt/reficcmax/bin/iccDumpProfile', '-v', '<inputFile>'],
          timeoutScale: 18,
          version: 'test',
          parse: {
            type: 'regex-counter',
            stdstar: {
              '.*': {
                nameReplace: {'[0-9]': ''},
              },
            },
          },
        },
        refIccMaxToXml: {
          exec: ['bash', '-c',
              '/opt/reficcmax/bin/iccToXml "$0" "$1" ; /opt/reficcmax/bin/iccFromXml "$1" "$2"',
              '<inputFile>', '<tempFile .xml>', '<tempFile .icc>'],
          timeoutScale: 18,
          version: 'test6',
          parse: {
            type: 'regex-counter',
            stdstar: {
              '.*': {
                nameReplace: {'[0-9]': ''},
              },
            },
          },
        },
    },

    decision_default: '\
# Any line beginning with a hash is a comment.  \n\
filters:  \n\
  # Filters are defined as groups of regular expressions.  \n\
\n\
  S1 all:  \n\
    # These are our filters from demo 1  \n\
    # A comment must not be inserted on the same line as a regular expression!  \n\
    ^caradoc-stats_[a-zA-Z0-9_/ ]+  \n\
    ^caradoc-strict_[a-zA-Z0-9_/ ]+  \n\
    ^pdfid[a-zA-Z0-9 _/%]+  \n\
    ^pdfid_Date:  \n\
    ^pdfinfo[a-zA-Z0-9 _]+  \n\
    ^pdfinfo-struct_Syntax Warning  \n\
    ^pdfinfo-struct_struct  \n\
    ^pdfinfo-meta_meta not implemented$  \n\
    ^qpdf-check_.*WARNING.*  \n\
    ^qpdf-check_[a-z ]+$  \n\
    ^mutool-clean_  \n\
    ^mutool-convert-pdf_  \n\
    <<workbench: Exit code  \n\
  \n\
  S2:  \n\
    # We\'ve talked about linearized files being unsafe...  \n\
    ^qpdf-check_file is linearized$  \n\
  \n\
  ValidMustHave:  \n\
    ^pdfid_%%EOF  \n\
  \n\
  ValidCannotHave:  \n\
    ^pdfinfo-struct_struct  \n\
    ^qpdf-check_.*ERROR.*  \n\
    ^qpdf-check_.*WARNING.*  \n\
  \n\
  ValidWarningsBad:  \n\
    ^caradoc-strict_PDF error : Xref table contains object that does not exist in object  \n\
    ^mutool-convert-pdf_error: cannot find .*  \n\
    ^mutool-convert-pdf_warning: non-page object in page tree  \n\
    ^mutool-convert-pdf_error: invalid key in dict  \n\
    ^mutool-convert-pdf_error: invalid indirect reference in dict  \n\
    ^mutool-convert-pdf_error: unknown token in dict  \n\
    #^mutool-convert-pdf_warning: cannot create ToUnicode mapping for  \n\
  \n\
  ValidWarningsXrefRebuild:  \n\
    ^qpdf-check_WARNING: xref not found  \n\
    ^pdfinfo-struct_Internal Error: xref num  not found but needed, try to reconstruct  \n\
    ^caradoc-strict_PDF error : Xref does not start at object  in object trailer at offset  \n\
    ^mutool-convert-pdf_warning: trying to repair broken xref  \n\
  \n\
  XrefIsAmbiguous:  \n\
    shared identifier entries  \n\
  \n\
  RejectedAmbiguousBad:  \n\
    ^qpdf-check_WARNING: loop detected following xref tables  \n\
    # This one is unreliable, and refers to previous lines in output ^mutool-convert-pdf_warning: unrecoverable error; ignoring rest of page  \n\
    ^mutool-convert-pdf_error: Unable to read ICC workflow  \n\
    # This one often applies to xref issues; ^mutool-convert-pdf_warning: repairing PDF document  \n\
    ^caradoc-stats_PDF error : Lexing error : integer error : integer overflow at offset  \n\
    ^mutool-convert-pdf_error: malformed page tree  \n\
  \n\
  RejectedBad:  \n\
    ^mutool-convert-pdf_error: no objects found  \n\
    ^caradoc-stats_PDF error : Lexing error : unexpected character : at offset  \n\
    ^pdfinfo-struct_Syntax Error \\(\\): Illegal character <> in hex string  \n\
    ^pdftocairo-pdf_Syntax Error \\(\\): Illegal character \'}\'  \n\
    ^pdftocairo-pdf_Syntax Error  \n\
    ^qpdf-check_WARNING: operation for dictionary attempted on object of type null: returning null for attempted key retrieval  \n\
    ^pdfinfo-struct_Syntax Error: Invalid object stream  \n\
  \n\
  SafeWarnings:  \n\
    ^qpdf-check_WARNING: unknown token while reading object; treating as string  \n\
    ^pdfid_/URI  \n\
    ^caradoc-stats_PDF error : Lexing error : integer error : integer overflow at offset  \n\
    ^caradoc-strict_PDF error : Xref does not start at object  in object trailer at offset  \n\
    After last %%EOF  \n\
    /Colors > 2^24  \n\
  \n\
  UnsafeWarnings:  \n\
    ^qpdf-check_WARNING: loop detected following xref tables  \n\
    ^pdfid_/OpenAction  \n\
    ^pdfinfo_Syntax Error \\(\\): Dictionary key must be a name object  \n\
    ^mutool-convert-pdf_warning: non-page object in page tree  \n\
  \n\
outputs:  \n\
  # Standard output status -- If a PDF passes filter S1, it will be "valid",  \n\
  # otherwise "rejected".  \n\
  status:  \n\
    "valid" is !(RejectedBad | RejectedAmbiguousBad | ValidWarningsXrefRebuild & XrefIsAmbiguous)  \n\
    "rejected" else  \n\
  \n\
  # Mark anything that is linearized as "rejected-unsafe", and otherwise  \n\
  # mark it as "valid".  \n\
  validity-status:  \n\
    "rejected" is RejectedBad  \n\
    "rejected-ambiguous" is RejectedAmbiguousBad | (ValidWarningsXrefRebuild & XrefIsAmbiguous)  \n\
    "valid-warnings" is ValidWarningsBad | !ValidMustHave | ValidCannotHave | ValidWarningsXrefRebuild  \n\
    "valid" else  \n\
    "rejected-unsafe"  \n\
  \n\
  safety-status:  \n\
    "unsafe"  \n\
    "unsafe-warnings" is UnsafeWarnings  \n\
    "safe-warnings" is SafeWarnings  \n\
    "safe" else  \n\
  ',

    decision_views: {
    },

    file_detail_views: {
    },

    build: {
        // The software environment must be defined.  It optionally may be grouped
        // into different build stages, which map to stages in docker.
        stages: {
            // Defining docker stages -- there MUST be a 'base' stage, which is
            // automatically included in final output.
            // Other stages with `copy_output` defined will also be included
            // in the final output.
            // Stages are written to the Dockerfile in order.  Most plugins will
            // only need to modify the 'final' stage's commands.

            // The base stage must have a 'from', which defines the base
            // image.  Other stages may also specify 'from'; otherwise,
            // `from: 'base'` is implied.

            // The 'final' stage is special -- it only allows commands, and
            // any commands executed are executed only in the final image.

            // Each stage may have a 'copy_output', which defines the outputs
            // produced by the stage.  The key is the absolute path to the file
            // or directory to be copied (may have asterisk wildcards), and the
            // value is either `true` to copy to the same absolute path, or a
            // new copy destination.  When specifying a new destination,
            // if that destination is a directory, append a trailing slash.

            // Each stage may have a 'commands', which specifies commands to
            // run.

            // Optimization note: every time 'base' gets updated, there may
            // be a long recompilation process. Ideally, most development work
            // should not touch 'base'. One way around this is for other images
            // to specify their own 'from' keys.

            base: {
                'from': 'ubuntu:18.04',
                commands: [
                    // Base packages
                    'RUN apt-get update && apt-get install -y \
                        curl \
                        python3 \
                        python3-pip \
                        xpdf \
                        wget \
                        ',
                    // Note that we will *also* install a newer version of poppler in /usr/local/bin
                    'RUN apt-get update && apt-get install -y \
                        poppler-utils \
                        ',
                    // Documented caradoc dependencies
                    'RUN apt-get update && apt-get install -y \
                        ocaml \
                        opam \
                        zlib1g-dev \
                        ',
                    // Undocumented caradoc dependencies
                    'RUN apt-get update && apt-get install -y \
                        m4 \
                        pkg-config \
                        libgmp3-dev \
                        ',
                    // Requirements for building poppler utils from source
                    // No effort has been made to distinguish what's required only
                    // for the build, so we install them all up front.
                    'RUN apt-get update && apt-get install -y \
                        uuid-dev \
                        gperf \
                        libtool \
                        gettext \
                        autopoint \
                        autoconf \
                        python3-dev \
                        libssl-dev \
                        cmake \
                        libfreetype6-dev \
                        libxcb-composite0-dev \
                        libxml2-dev \
                        ',
                    // Needed to build pdftocairo target in poppler
                    'RUN apt-get update && apt-get install -y \
                        libcairo2-dev \
                        ',
                    // Needed to build qpdf
                    'RUN apt-get update && apt-get install -y \
                        libjpeg-dev \
                        ',
                ],
            },

            refIccMax: {
              copy_output: {
                '/opt/reficcmax': true,
                '/opt/reficcmax/lib': '/usr/lib',
              },
              commands: [
                'RUN git clone https://github.com/InternationalColorConsortium/RefIccMAX \
                  && cd RefIccMAX && mkdir build && cd build \
                  && cmake -DCMAKE_INSTALL_PREFIX=/opt/reficcmax ../Build/Cmake \
                  && make \
                  && make install',
              ],
            },

            // final is a special stage which runs in the final image.  Useful
            // for installing dependencies for downstream tools, without needing
            // to rebuild all of the other workbench internals.
            final: {
                commands: [
                    // Note that {dist} gets replaced in Dockerfile commands with
                    // the directory containing `config.json5`
                    'RUN apt-get update && apt-get install -y argyll liblcms2-utils',
               ],
            },
        },
    },
}
